---
phase: 04-smart-contract-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - front-end/src/hooks/counterQueries.ts
  - front-end/src/hooks/useTransactionStatus.ts
autonomous: true

must_haves:
  truths:
    - "useCounterValue hook fetches counter value from contract"
    - "useIncrementCounter mutation executes increment transaction"
    - "useDecrementCounter mutation executes decrement transaction"
    - "useTransactionStatus hook polls transaction status until terminal state"
  artifacts:
    - path: "front-end/src/hooks/counterQueries.ts"
      provides: "Counter contract hooks"
      exports: ["useCounterValue", "useIncrementCounter", "useDecrementCounter"]
      min_lines: 80
    - path: "front-end/src/hooks/useTransactionStatus.ts"
      provides: "Transaction status polling"
      exports: ["useTransactionStatus"]
      min_lines: 30
  key_links:
    - from: "front-end/src/hooks/counterQueries.ts"
      to: "@stacks/blockchain-api-client"
      via: "callReadOnlyFunction API"
      pattern: "smartContractsApi.callReadOnlyFunction"
    - from: "front-end/src/hooks/counterQueries.ts"
      to: "front-end/src/lib/contract-utils.ts"
      via: "executeContractCall for devnet"
      pattern: "executeContractCall"
    - from: "front-end/src/hooks/useTransactionStatus.ts"
      to: "@stacks/blockchain-api-client"
      via: "getTransactionById API"
      pattern: "transactionsApi.getTransactionById"
---

<objective>
Create React Query hooks for counter contract read and write operations.

Purpose: CONT-03, CONT-04, CONT-05 require frontend hooks to read counter value, execute transactions, and track transaction status. This plan creates all contract interaction hooks.

Output: counterQueries.ts with useCounterValue/useIncrementCounter/useDecrementCounter, useTransactionStatus.ts
</objective>

<execution_context>
@/Users/kenny/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kenny/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-smart-contract-integration/04-RESEARCH.md

# Existing patterns to follow
@front-end/src/hooks/campaignQueries.ts
@front-end/src/hooks/chainQueries.ts
@front-end/src/lib/contract-utils.ts
@front-end/src/lib/stacks-api.ts
@front-end/src/components/providers/wallet-provider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create counterQueries.ts with useCounterValue hook</name>
  <files>front-end/src/hooks/counterQueries.ts</files>
  <action>
Create counterQueries.ts with useCounterValue hook following the campaignQueries.ts pattern:

```typescript
import { useQuery, useMutation, useQueryClient, UseQueryResult } from "@tanstack/react-query"
import { getApi, getStacksUrl } from "@/lib/stacks-api"
import { cvToJSON, hexToCV, PostConditionMode } from "@stacks/transactions"
import { COUNTER_CONTRACT } from "@/constants/contracts"
import { useWallet } from "@/components/providers/wallet-provider"
import { executeContractCall, openContractCall } from "@/lib/contract-utils"
import { toast } from "sonner"

export const useCounterValue = (): UseQueryResult<number> => {
  const api = getApi(getStacksUrl()).smartContractsApi

  return useQuery<number>({
    queryKey: ["counterValue"],
    queryFn: async () => {
      const response = await api.callReadOnlyFunction({
        contractAddress: COUNTER_CONTRACT.address || "",
        contractName: COUNTER_CONTRACT.name,
        functionName: "get-count",
        readOnlyFunctionArgs: {
          sender: COUNTER_CONTRACT.address || "",
          arguments: [],
        },
      })

      if (response?.okay && response?.result) {
        const result = cvToJSON(hexToCV(response.result))
        // get-count returns (ok uint), so check success and extract value
        if (result?.success) {
          return parseInt(result.value.value, 10)
        } else {
          throw new Error("Contract returned error response")
        }
      } else {
        throw new Error(response?.cause || "Error fetching counter value")
      }
    },
    refetchInterval: 10000, // Poll every 10 seconds
    retry: 3, // Retry 3 times to handle devnet block 2 delay
  })
}
```

Key patterns from RESEARCH.md:
- Use retry: 3 to handle devnet block 2 deployment timing
- Parse (ok value) response structure via result.success check
- 10s refetchInterval matches existing campaignQueries pattern
  </action>
  <verify>TypeScript compiles: `cd /Users/kenny/Code/stacks-starter/front-end && pnpm tsc --noEmit`</verify>
  <done>useCounterValue hook exports from counterQueries.ts and compiles without errors</done>
</task>

<task type="auto">
  <name>Task 2: Add mutation hooks for increment and decrement</name>
  <files>front-end/src/hooks/counterQueries.ts</files>
  <action>
Add useIncrementCounter and useDecrementCounter mutations to counterQueries.ts:

```typescript
export const useIncrementCounter = () => {
  const { isDevnet, devnetWallet, isConnected } = useWallet()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async () => {
      if (!isConnected) {
        throw new Error("Wallet not connected")
      }

      const txOptions = {
        contractAddress: COUNTER_CONTRACT.address || "",
        contractName: COUNTER_CONTRACT.name,
        functionName: "increment",
        functionArgs: [],
        postConditionMode: PostConditionMode.Allow,
      }

      if (isDevnet) {
        // Devnet: Direct signing without wallet extension
        return await executeContractCall(txOptions, devnetWallet)
      } else {
        // Testnet/Mainnet: Use Leather wallet
        return await openContractCall(txOptions)
      }
    },
    onSuccess: (data) => {
      toast.success("Transaction submitted", {
        description: `TX: ${data.txid.slice(0, 10)}...`,
      })
      // Invalidate counter query to trigger refetch
      queryClient.invalidateQueries({ queryKey: ["counterValue"] })
    },
    onError: (error: Error) => {
      toast.error("Transaction failed", {
        description: error.message,
      })
    },
  })
}

export const useDecrementCounter = () => {
  const { isDevnet, devnetWallet, isConnected } = useWallet()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async () => {
      if (!isConnected) {
        throw new Error("Wallet not connected")
      }

      const txOptions = {
        contractAddress: COUNTER_CONTRACT.address || "",
        contractName: COUNTER_CONTRACT.name,
        functionName: "decrement",
        functionArgs: [],
        postConditionMode: PostConditionMode.Allow,
      }

      if (isDevnet) {
        return await executeContractCall(txOptions, devnetWallet)
      } else {
        return await openContractCall(txOptions)
      }
    },
    onSuccess: (data) => {
      toast.success("Transaction submitted", {
        description: `TX: ${data.txid.slice(0, 10)}...`,
      })
      queryClient.invalidateQueries({ queryKey: ["counterValue"] })
    },
    onError: (error: Error) => {
      toast.error("Transaction failed", {
        description: error.message,
      })
    },
  })
}
```

Key patterns:
- Check isConnected before executing
- Use executeContractCall for devnet (direct signing)
- Use openContractCall for testnet/mainnet (Leather wallet)
- Invalidate counterValue query on success to trigger refetch
- Toast feedback for success/error states
  </action>
  <verify>TypeScript compiles: `cd /Users/kenny/Code/stacks-starter/front-end && pnpm tsc --noEmit`</verify>
  <done>useIncrementCounter and useDecrementCounter hooks export and compile</done>
</task>

<task type="auto">
  <name>Task 3: Create useTransactionStatus hook</name>
  <files>front-end/src/hooks/useTransactionStatus.ts</files>
  <action>
Create useTransactionStatus.ts for polling transaction status:

```typescript
import { useQuery } from "@tanstack/react-query"
import { getApi, getStacksUrl } from "@/lib/stacks-api"

export type TxStatus = "pending" | "success" | "abort_by_response" | "abort_by_post_condition"

interface TransactionStatusResult {
  status: TxStatus
  blockHeight?: number
  isConfirmed: boolean
  isFailed: boolean
}

export const useTransactionStatus = (txid: string | null) => {
  const api = getApi(getStacksUrl()).transactionsApi

  return useQuery<TransactionStatusResult>({
    queryKey: ["transactionStatus", txid],
    queryFn: async () => {
      if (!txid) throw new Error("No transaction ID")

      const tx = await api.getTransactionById({ txId: txid })
      const status = tx.tx_status as TxStatus
      const isConfirmed = status === "success"
      const isFailed = status.includes("abort")

      return {
        status,
        blockHeight: tx.block_height,
        isConfirmed,
        isFailed,
      }
    },
    enabled: !!txid,
    refetchInterval: (query) => {
      // Stop polling once transaction reaches terminal state
      const data = query.state.data
      if (data?.isConfirmed || data?.isFailed) {
        return false
      }
      return 3000 // Poll every 3 seconds while pending
    },
    retry: false,
  })
}
```

Key patterns from RESEARCH.md:
- enabled: !!txid - only poll when we have a transaction ID
- refetchInterval returns false to stop polling on terminal states
- 3 second polling interval for responsive UI
- Returns structured result with isConfirmed/isFailed booleans for easy consumption
  </action>
  <verify>TypeScript compiles: `cd /Users/kenny/Code/stacks-starter/front-end && pnpm tsc --noEmit`</verify>
  <done>useTransactionStatus hook exists and compiles; handles pending/success/abort states</done>
</task>

</tasks>

<verification>
1. `cd /Users/kenny/Code/stacks-starter/front-end && pnpm tsc --noEmit` passes
2. counterQueries.ts exports useCounterValue, useIncrementCounter, useDecrementCounter
3. useTransactionStatus.ts exports useTransactionStatus
4. All hooks import from correct paths (stacks-api, contract-utils, wallet-provider)
5. Mutations use correct devnet vs testnet/mainnet branching
</verification>

<success_criteria>
- useCounterValue reads counter from contract via callReadOnlyFunction
- useIncrementCounter and useDecrementCounter execute transactions
- Mutations handle devnet (direct) vs testnet/mainnet (Leather) paths
- useTransactionStatus polls until terminal state then stops
- All hooks compile and export correctly
</success_criteria>

<output>
After completion, create `.planning/phases/04-smart-contract-integration/04-02-SUMMARY.md`
</output>
